# 미션 - 로또

순수한 Java를 활용한 로또 구현 프로젝트입니다.

## 기능 요구사항
 * 로또 번호는 1 ~ 45 사이의 숫자이다.
 * 로또 번호는 6자리이며 중복될 수 없다.
 * 로또의 당첨 번호는 랜덤으로 생성된다.
 * 로또의 가격은 한 장에 1000원이다.
 * 로또는 여러 장 구매 가능하다.
 * 로또는 1인당 최대 10만원 까지 구매 가능하다.
 * 로또 구매는 자동으로 이루어진다. 즉 랜덤으로 번호가 부여된다.
 * 당첨 번호 조회가 완료되면 수익률을 계산하여 보여준다.

## 입출력 요구사항

```
구매할 로또의 개수를 입력해주세요.
10

금액은 10000원 입니다. 구입 금액을 입력해주세요.
10000

금주의 당첨 번호는 1, 10, 12, 32, 36, 43 입니다.

당신의 수익률은 아래와 같습니다.
구매 개수: 10
구매 금액: 10000
최대 당첨 등수: ?등
총 당첨 금액: ????????
수익율: ??.??%
```

## 설계 원칙

> 설계 원칙은 [목적의식 있는 연습을 통한 효과적인 학습](https://brunch.co.kr/@javajigi/8) 해당 글에 담긴 피드백을 통해 반영 및 재구성 하였습니다.

### 이름을 통해 의도를 드러내라
협업을 위해 가장 중요한 활동 중 하나는 좋은 이름 짓기이다. 변수 이름, 메서드 이름, 클래스 이름을 짓는데 시간을 투자한다.
이름을 통해 변수의 역할, 함수의 역할, 클래스의 역할에 대한 의도를 드러내기 위해 노력한다.

또한 축약하지 않는다. 의도를 드러낼 수 있다면 이름이 길어져도 괜찮다.

### 공백도 코딩 컨벤션의 일부분이다
공백 라인을 의미 있게 사용하는 것이 좋아 보이며, 문맥을 분리하는 부분에 사용하는 것이 좋다.

### 반복하지 마라
중복은 소프트웨어에서 모든 악의 근원이다.

### 의미 없는 주석을 달지 않는다
변수 이름, 메서드 이름을 통해 의도를 드러낸다.

### 커밋 메시지를 의미 있게 작성하라
커밋 메시지에 해당 커밋에서 작업한 내용에 대한 이해가 가능하도록 작성한다.

### 기능 목록을 업데이트하라
`README.md`파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다.
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담감을 가지기 보다 기능을 구현하면서 문서를 계속 업데이트 한다.
죽은 문서가 아니라 `살아 있는 문서`를 만들기 위해 노력한다.

구현해야 할 기능 목록을 정리하는데 집중한다. `정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록`에 정리한다.

### 매직 넘버, 매직 리터럴을 사용하지 마라
의미를 나타낼 수 있는 상수 (static final)로 치환하여 코드의 가독성을 높인다.

### 구현 순서도 코딩 컨벤션이다
* [형식 맞추기](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/clean-code/match-the-format.html)

### 메서드 라인은 15줄, depth는 2까지 허용한다
만약 whil문 안에 if이 있으면 depth는 2가 된다. depth를 줄이는 방법은 메서드를 분리하면 된다.

### 3항 연산자를 쓰지 않는다

### else 예약어를 쓰지 않는다
if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
* [다형성을 사용해 if/else를 제거하는 리팩토링을 하라.](https://slipp.net/questions/566)

### Java Collection을 사용하라
Java Collection 자료구조를 사용하면 데이터를 조작할 때 다양한 api를 사용할 수 있다.

### 객체에게 메시지를 보내라
상태를 가지는 객체에게 데이터를 꺼내려 하지말고 객체에게 메시지를 보낸다.

### 인스턴스 변수의 수를 줄이기 위해 노력한다
인스턴스 변수의 수가 많은 것은 객체의 복잡도를 높이고, 버그 발생 가능성을 높일 수 있다. 불필요한 인스턴스 변수를 줄여 최소화한다.

### 비즈니스 로직과 UI 로직을 분리해라
비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다.
현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 `toString()`을 통해 구현한다.
View에서 사용할 데이터라면 `getter 메서드`를 통해 데이터를 전달한다.

### 원시 타입과 문자열을 포장하라
* [모든 원시값과 문자열을 포장하라](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/woowacourse/precourse-2.html#_8-%E1%84%86%E1%85%A9%E1%84%83%E1%85%B3%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA-%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%91%E1%85%A9%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1)
* [원시 타입을 포장해야 하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/)

### 클래스 우선이 아닌, 객체의 속성과 행위가 우선이다
클래스는 객체를 추상화하는 도구일 뿐이다.

### 데이터가 아닌 메시지를 중심으로 객체를 설계해라
객체는 혼자 있을 수 없다. 다른 객체와의 `협력` 안에서만 존재할 수 있다.
메시지를 중심으로, 해당 메시지가 어떤 객체를 필요로 하는지 생각한다.

### 하나하나 지시하지 말고 요청해라
예를 들면, 판사가 증인에게 1) 목격 했던 장면을 떠올리고, 2) 떠오르는 시간을 순서대로 구성하고, 3) 말로 간결하게 표현해라 라고 요청하지 않는다. 그냥 "증언하라"라고 요청한다.
마찬가지로 객체의 설계 단계에서도 책임이 있는 객체에 요청만 하도록 설계한다.

### 하나의 메서드는 하나의 일만 해야 한다
처음부터 완벽한 설계는 없다. 설계를 코드로 구현해가는 과정에서 수정이 필요하다면 설계를 수정한다.

## References
* [목적의식 있는 연습을 통한 효과적인 학습](https://brunch.co.kr/@javajigi/8)
* [순수 Java로 이루어진 프로젝트](https://github.com/jojoldu/oop-java)
* [java-vendingmachine-precourse](https://github.com/woowacourse/java-vendingmachine-precourse)